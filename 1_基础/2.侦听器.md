# 侦听器

## vue如何启用侦听器

调用 watch 时，Vue 会：

创建一个用于读取依赖的 getter

用 getter 创建一个 ReactiveEffect（副作用实例），内部保存 cleanup

初始化watcher

运行 getter 收集依赖并记录初始值

当依赖变化时，触发调度器

调度器执行 watcher 的 job：

- 先执行上一次注册的 cleanup

- 获取新的值

- 调用用户回调

- 注册下一次 cleanup

- 保存 newValue → oldValue

组件卸载时，Vue 自动停止 effect 并执行 cleanup

整个 watch 实例是独立存在的，cleanup 存储在 watch 自己的 effect 实例里。

## 关于响应式的深层嵌套

在 vue 中, watch 函数可以直接监听对象数据的变化, 且是深层的, 但是 newValue 和 oldValue 是相等的, 但回调函数仍然能执行。

如果是 getter 函数返回的对象, 除非整个对象被替换，否则不会触发回调函数。但可以显式 deep 选项来监听深层嵌套对象的变化。

```js
watch(
  () => state.someObject,
  (newValue, oldValue) => {
    // 注意：`newValue` 此处和 `oldValue` 是相等的
    // *除非* state.someObject 被整个替换了
  },
  { deep: true }
);
```

## 即时回调的侦听器

在建立监听时回调

```js
watch(
  source,
  (newValue, oldValue) => {
    // 立即执行，且当 `source` 改变时再次执行
  },
  { immediate: true }
);
```

## watchEffect()

侦听器的回调使用与源完全相同的响应式状态是很常见的。例如下面的代码，在每当 todoId 的引用发生变化时使用侦听器来加载一个远程资源：

```js
const todoId = ref(1);
const data = ref(null);

watch(
  todoId,
  async () => {
    const response = await fetch(
      `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
    );
    data.value = await response.json();
  },
  { immediate: true }
);
```

使用 watchEffect()简化

```js
watchEffect(async () => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  );
  data.value = await response.json();
});
```

watcheffect()会监听回调函数中的响应式数据, 并且在初次监听时立即调用回调函数

好处:

    对于这种只有一个依赖项的例子来说，watchEffect() 的好处相对较小。但是对于有多个依赖项的侦听器来说，使用 watchEffect() 可以消除手动维护依赖列表的负担。此外，如果你需要侦听一个嵌套数据结构中的几个属性，watchEffect() 可能会比深度侦听器更有效，因为它将只跟踪回调中被使用到的属性，而不是递归地跟踪所有的属性。

## 异步回调清理(3.5+)

比如在异步请求时, 如果数据更新但旧的请求没有完成, 我们又需要用新的请求, 这时在回调函数中用**onWatcherCleanup()** API 来清理旧的请求。

```js
import { watch, onWatcherCleanup } from "vue";

watch(id, (newId) => {
  const controller = new AbortController();

  fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {
    // 回调逻辑
  });

  onWatcherCleanup(() => {
    // 终止过期请求
    controller.abort();
  });
});
```

注意, 不能在 await 之后调用它, 因为请求会阻塞线程, 函数得不到调用

## 异步回调清理(3.5-)

```js
watch(id, (newId, oldId, onCleanup) => {
  // ...
  onCleanup(() => {
    // 清理逻辑
  });
});

watchEffect((onCleanup) => {
  // ...
  onCleanup(() => {
    // 清理逻辑
  });
});
```

## 回调的触发时机

触发的时机在组件更新之后, DOM 渲染之前

在 DOM 更新之后访问 DOM

```js
watch(source, callback, {
  flush: "post",
});

watchEffect(callback, {
  flush: "post",
});
```

## 同步侦听器

它会在 vue 进行任何更新前触发

```js
watch(source, callback, {
  flush: "sync",
});

watchEffect(callback, {
  flush: "sync",
});
```

## 停止侦听器

避免异步创建侦听器

调用停止侦听器函数可以停止侦听器的执行

```js
const stop = watch(source, callback);

// 停止侦听器
stop();
```

## 几个参数

```js
watch(
  source,
  () => {},
  { deep: true },
  { immediate: true },
  { flush: "post" | "sync" }
);
```
