# 依赖注入

Props 对于父组件向子组件传递信息时比较方便, 但向孙子组件传递时比较麻烦。

解决方案: provide(提供) 和 inject(注入)

## provide

要为组件后代提供数据，需要使用到 provide() 函数：

是一个 key-value 对，key 为字符串, value 为任意类型, 包括 ref()。

```vue
<script setup>
import { provide } from "vue";

provide(/* 注入名 */ "message", /* 值 */ "hello!");
</script>
```

## inject

要从祖先组件中获取数据，需要使用到 inject() 函数

若多个父组件提供了相同的 key, 则使用组件链最近的祖先组件

注入名必须与 provide() 的注入名一致。

```vue
<script setup>
import { inject } from "vue";
// 默认值, 可选
const message = inject(/* 注入名 */ "message", "default message");

const value = inject("key", () => new ExpensiveClass(), true);
// true 表示默认值应被当成一个工厂函数
</script>
```

### inject 注入响应式数据

当提供注入响应式的数据时，建议尽可能将任何对响应式状态的变更都保持在供给方组件中。

我们可能需要在注入方组件中更改数据。在这种情况下，我们推荐在供给方组件内声明并提供一个更改数据的方法函数:

```vue
<!-- 在供给方组件内 -->
<script setup>
import { provide, ref } from "vue";

const location = ref("North Pole");

function updateLocation() {
    location.value = "South Pole";
}

provide("location", {
    location,
    updateLocation,
});
</script>
```

```vue
<!-- 在注入方组件 -->
<script setup>
import { inject } from "vue";

const { location, updateLocation } = inject("location");
</script>

<template>
    <button @click="updateLocation">{{ location }}</button>
</template>
```

确保提供的数据不能被注入方的组件更改，可以使用 readonly() 来包装提供的值:

```vue
<script setup>
import { ref, provide, readonly } from "vue";

const count = ref(0);
provide("read-only-count", readonly(count));
</script>
```

### inject 使用 Symbol 作为注入名

通常把 Symbol 定义在单独的文件中

```js
// my-symbols.js
export const mySymbol = Symbol("mySymbol");
```

```js
// 祖先组件
import { provide } from "vue";
import { mySymbol } from "./my-symbols";

provide(mySymbol, "hello");
```

```js
// 后代组件
import { inject } from "vue";
import { mySymbol } from "./my-symbols";

const message = inject(mySymbol, "default message");
```
