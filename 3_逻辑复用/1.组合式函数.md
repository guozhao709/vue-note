# 组合式函数

一般来说, 我们会封装一个无状态函数, 提高代码的复用性

那组合式函数, 封装的是有状态函数, 被组件调用时会创建一个实例。 也就是说, 可以在多个组件中复用且不会相互影响

## 普通示例

例如(读取界面中的鼠标位置):

```js
import { ref, onMounted, onUnmounted } from "vue";

export function useMousePosition() {
    const x = ref(0);
    const y = ref(0);

    function updateMousePosition(event) {
        x.value = event.pageX;
        y.value = event.pageY;
    }

    onMounted(() => {
        return window.addEventListener("mousemove", updateMousePosition);
    });
    // 当事件监听定义到window上, 需手动销毁
    onUnmounted(() => {
        return window.removeEventListener("mousemove", updateMousePosition);
    });

    return { x, y };
}
```

```vue
<template>
    <div>鼠标位置: ({{ x }}, {{ y }})</div>
</template>

<script setup>
import { useMousePosition } from "./mousePosition";

const { x, y } = useMousePosition();
</script>
```

## 接收响应式状态

以 useFectch() 为例, 此组合函数可以接收一个 ref 或者 getter 函数

```js
import { useFetch } from "./fetch";

const url = ref(initialUrl);

const { data, error } = useFetch(url);

url.value = newUrl; // 切换url, 重新请求数据
```

在组合函数中

```js
import { ref, watchEffect, toValue } from "vue";

export function useFetch(url) {
    const data = ref(null);
    const error = ref(null);

    const fetchData = () => {
        data.value = null;
        error.value = null;

        fetch(toValue(url))
            .then((res) => res.json())
            .then((json) => {
                data.value = json;
            })
            .catch((err) => {
                error.value = err;
            });
    };

    // 监听url变化, 重新请求数据
    watchEffect(() => {
        fetchData();
    });

    // // 用 watch 实现类似效果
    // watch(
    //     () => toValue(url), // 手动指定监听的依赖
    //     () => fetchData(),
    //     { immediate: true } // 初始化时执行一次
    // );

    return { data, error };
}
```

## 组合式函数的注意事项

### 返回值

组合式函数的返回值是一个非响应式的对象, 但对象的属性 可以是响应式的 ref

可以使用 const mouse = reactive(useMousePosition()); 来包装返回值, 使其成为响应式的对象, ref 则会自动解包

### 使用限制

组合式函数只能在 `<script setup>` 或 `setup()` 钩子中被调用。在这些上下文中，它们也只能被同步调用。在某些情况下，也可以在像 `onMounted()` 这样的生命周期钩子中调用它们。

这样才能:

1. 将生命周期钩子注册到该组件实例上

2. 将计算属性和监听器注册到该组件实例上，以便在该组件被卸载时停止监听，避免内存泄漏。
