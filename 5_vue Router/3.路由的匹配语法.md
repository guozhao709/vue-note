# 路由的匹配语法

## 在路由参数中使用正则

eg:

```js
const routes = [
  // /o/:Id 匹配数字
  {
    path: "/o/:Id",
  },
  {
    // /p/:name 匹配其他任何内容
    path: "/p/:name",
  },
];
```

但我们不想要/o 和/p 前缀, 可以这样写

```js
const routes = [
    {
        path: "/:Id(\\d+)" // 注意转义字符
    }
    {
        path: "/:name"
    }
]
```

## 可重复的参数

我的 url 是 /one/two/three

对应 path 是:

1. "/:chapters+" (/one/two/three)
2. "/:chapters*" (/ 或 /one 或 /one/two 或 /one/two/three)
3. "/:chapters(//d+)" => /1/2/3

如果要使用路由跳转:

```js
router.push({
  name: "chapters",
  params: { chapters: ["one", "two", "three"] }, // 这个是数组
});
```

## Sensitive(默认匹配) 与 strict 路由配置

url:

1. /User/123
2. /user/123
3. /User/123/

path: "/user/:id"

默认情况下, 路由匹配是不区分大小写和最后面的 / , 所以以上三个 url 都会匹配到 /user/:id

如果我们想区分大小写, 并且严格匹配最后面的 /, 我们可以这样配置:

```js
const routes = [
  {
    path: "/user/:id",
    // 开启严格匹配
    strict: true,
  },
];

const router = createRouter({
  history: createWebHashHistory(),
  routes,
  strict: true, // 全局开启严格匹配
});

// 只能匹配url: /user/123, 其他的不能匹配
```

## 可选参数

path: "/User/:name?"

url: 

1. /User
2. /User/guo

当参数为1个时与 * 效果相同, ? 匹配0个或1个

路径排名工具:

https://paths.esm.dev/?p=AAMeJSyAwR4UbFDAFxAcAGAIJXMAAA..

## 总结

路由path的正则表达

## 复习

2025/11/27
下一次: 2025/12/03